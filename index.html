<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Three.js + Cannon-es Demo</title>
    <style>
      html,
      body {
        margin: 0;
        height: 100%;
        overflow: hidden;
      }

      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <script type="module">
      import * as THREE from 'https://unpkg.com/three@0.165.0/build/three.module.js';
      import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

      // Scene setup
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb);

      const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        150
      );
      camera.position.set(0, 6, 12);
      camera.lookAt(0, 1, 0);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      document.body.appendChild(renderer.domElement);

      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
      directionalLight.position.set(5, 10, 5);
      scene.add(directionalLight);

      // Physics world setup
      const world = new CANNON.World({
        gravity: new CANNON.Vec3(0, -9.82, 0),
      });

      world.defaultContactMaterial.friction = 0.35;
      world.defaultContactMaterial.restitution = 0.08;

      // Mesh/body pairs to sync every frame
      const pairs = [];
      const instancedSyncGroups = [];
      const tmpMatrix = new THREE.Matrix4();
      const tmpPosition = new THREE.Vector3();
      const tmpQuaternion = new THREE.Quaternion();
      const tmpScale = new THREE.Vector3(1, 1, 1);

      const groundBody = new CANNON.Body({ mass: 0 });
      const groundShape = new CANNON.Plane();
      groundBody.addShape(groundShape);
      groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
      world.addBody(groundBody);

      const groundMesh = new THREE.Mesh(
        new THREE.PlaneGeometry(50, 50),
        new THREE.MeshStandardMaterial({ color: 0x2e8b57 })
      );
      groundMesh.rotation.x = -Math.PI / 2;
      scene.add(groundMesh);
      pairs.push({ mesh: groundMesh, body: groundBody });

      const carGroup = new THREE.Group();
      scene.add(carGroup);

      const bodySize = { x: 2.4, y: 0.7, z: 1.4 };
      const bodyMesh = new THREE.Mesh(
        new THREE.BoxGeometry(bodySize.x, bodySize.y, bodySize.z),
        new THREE.MeshStandardMaterial({ color: 0xff7f50, flatShading: true })
      );
      bodyMesh.position.y = 0.65;
      carGroup.add(bodyMesh);

      const wheelSize = { x: 0.45, y: 0.45, z: 0.3 };
      const wheelGeometry = new THREE.BoxGeometry(wheelSize.x, wheelSize.y, wheelSize.z);
      const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x1f1f1f, flatShading: true });
      const wheelOffsets = [
        new THREE.Vector3(0.75, 0.3, 0.65),
        new THREE.Vector3(-0.75, 0.3, 0.65),
        new THREE.Vector3(0.75, 0.3, -0.65),
        new THREE.Vector3(-0.75, 0.3, -0.65),
      ];

      for (const offset of wheelOffsets) {
        const wheelMesh = new THREE.Mesh(wheelGeometry, wheelMaterial);
        wheelMesh.position.copy(offset);
        carGroup.add(wheelMesh);
      }

      const carBody = new CANNON.Body({
        mass: 6,
        position: new CANNON.Vec3(0, 3, 0),
        linearDamping: 0.35,
        angularDamping: 0.45,
      });
      carBody.addShape(
        new CANNON.Box(new CANNON.Vec3(bodySize.x * 0.5, bodySize.y * 0.5, bodySize.z * 0.5)),
        new CANNON.Vec3(0, bodyMesh.position.y, 0)
      );

      for (const offset of wheelOffsets) {
        carBody.addShape(
          new CANNON.Box(new CANNON.Vec3(wheelSize.x * 0.5, wheelSize.y * 0.5, wheelSize.z * 0.5)),
          new CANNON.Vec3(offset.x, offset.y, offset.z)
        );
      }
      world.addBody(carBody);
      pairs.push({ mesh: carGroup, body: carBody });

      function spawnVoxelCity() {
        const gridSize = 3;
        const spacing = 4;
        const footprintSize = 2;
        const minHeight = 3;
        const maxHeight = 8;
        const blockSize = 1;
        const blockHalf = blockSize * 0.5;
        const cityOffset = new THREE.Vector3(0, 0, -18);
        const randomColor = () => 0x808080 + Math.floor(Math.random() * 0x3f3f3f);
        const voxelMaterial = new CANNON.Material('voxelBlock');
        voxelMaterial.friction = 0.18;
        voxelMaterial.restitution = 0.28;

        let totalBlocks = 0;
        const buildingHeights = [];
        for (let gx = 0; gx < gridSize; gx += 1) {
          buildingHeights[gx] = [];
          for (let gz = 0; gz < gridSize; gz += 1) {
            const height = minHeight + Math.floor(Math.random() * (maxHeight - minHeight + 1));
            buildingHeights[gx][gz] = height;
            totalBlocks += footprintSize * footprintSize * height;
          }
        }

        const blockGeometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
        const blockMaterial = new THREE.MeshStandardMaterial({
          color: 0xb0b0b0,
          roughness: 0.6,
          metalness: 0.05,
          vertexColors: true,
        });
        const blockMesh = new THREE.InstancedMesh(blockGeometry, blockMaterial, totalBlocks);
        blockMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        blockMesh.castShadow = false;
        blockMesh.receiveShadow = true;

        const color = new THREE.Color();
        const bodies = [];
        let blockIndex = 0;

        for (let gx = 0; gx < gridSize; gx += 1) {
          for (let gz = 0; gz < gridSize; gz += 1) {
            const baseX = (gx - (gridSize - 1) * 0.5) * spacing + cityOffset.x;
            const baseZ = (gz - (gridSize - 1) * 0.5) * spacing + cityOffset.z;
            const height = buildingHeights[gx][gz];

            for (let lx = 0; lx < footprintSize; lx += 1) {
              for (let lz = 0; lz < footprintSize; lz += 1) {
                for (let ly = 0; ly < height; ly += 1) {
                  const body = new CANNON.Body({
                    mass: 0.65,
                    linearDamping: 0.12,
                    angularDamping: 0.08,
                    material: voxelMaterial,
                    shape: new CANNON.Box(new CANNON.Vec3(blockHalf, blockHalf, blockHalf)),
                    position: new CANNON.Vec3(
                      baseX + (lx - (footprintSize - 1) * 0.5) * blockSize,
                      blockHalf + ly * blockSize,
                      baseZ + (lz - (footprintSize - 1) * 0.5) * blockSize
                    ),
                  });

                  world.addBody(body);
                  bodies.push(body);

                  color.setHex(randomColor());
                  blockMesh.setColorAt(blockIndex, color);
                  blockIndex += 1;
                }
              }
            }
          }
        }

        blockMesh.instanceColor.needsUpdate = true;
        scene.add(blockMesh);
        instancedSyncGroups.push({ mesh: blockMesh, bodies });
      }

      spawnVoxelCity();

      // Basic keyboard state (WASD)
      const keys = {
        KeyW: false,
        KeyA: false,
        KeyS: false,
        KeyD: false,
      };

      window.addEventListener('keydown', (event) => {
        if (event.code in keys) {
          keys[event.code] = true;
        }
      });

      window.addEventListener('keyup', (event) => {
        if (event.code in keys) {
          keys[event.code] = false;
        }
      });

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      const clock = new THREE.Clock();
      const fixedTimeStep = 1 / 60;
      const moveForce = 32;
      const steerTorque = 20;
      const forwardLocal = new CANNON.Vec3(0, 0, -1);
      const forwardWorld = new CANNON.Vec3();
      const forceVector = new CANNON.Vec3();
      const upAxis = new CANNON.Vec3(0, 1, 0);
      const currentVelocity = new CANNON.Vec3();
      const targetCameraPos = new THREE.Vector3();
      const carForward = new THREE.Vector3();
      const cameraUpOffset = new THREE.Vector3(0, 4, 0);

      function animate() {
        const delta = Math.min(clock.getDelta(), 0.1);
        world.step(fixedTimeStep, delta, 3);

        carBody.quaternion.vmult(forwardLocal, forwardWorld);

        if (keys.KeyW) {
          forwardWorld.scale(moveForce, forceVector);
          carBody.applyForce(forceVector, carBody.position);
        }
        if (keys.KeyS) {
          forwardWorld.scale(-moveForce, forceVector);
          carBody.applyForce(forceVector, carBody.position);
        }

        currentVelocity.copy(carBody.velocity);
        currentVelocity.y = 0;
        const speed = currentVelocity.length();
        if (speed > 0.2) {
          const steerInput = (keys.KeyA ? 1 : 0) - (keys.KeyD ? 1 : 0);
          if (steerInput !== 0) {
            const directionSign = Math.sign(currentVelocity.dot(forwardWorld)) || 1;
            upAxis.scale(steerInput * steerTorque * speed * 0.08 * directionSign, forceVector);
            carBody.torque.vadd(forceVector, carBody.torque);
          }
        }

        for (const { mesh, body } of pairs) {
          mesh.position.copy(body.position);
          mesh.quaternion.copy(body.quaternion);
        }

        for (const { mesh, bodies } of instancedSyncGroups) {
          for (let i = 0; i < bodies.length; i += 1) {
            const body = bodies[i];
            tmpPosition.copy(body.position);
            tmpQuaternion.copy(body.quaternion);
            tmpMatrix.compose(tmpPosition, tmpQuaternion, tmpScale);
            mesh.setMatrixAt(i, tmpMatrix);
          }
          mesh.instanceMatrix.needsUpdate = true;
        }

        carForward.set(0, 0, -1).applyQuaternion(carGroup.quaternion);
        targetCameraPos
          .copy(carGroup.position)
          .addScaledVector(carForward, -8)
          .add(cameraUpOffset);
        camera.position.lerp(targetCameraPos, 0.1);
        camera.lookAt(carGroup.position.x, carGroup.position.y + 1, carGroup.position.z);

        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }

      requestAnimationFrame(animate);
    </script>
  </body>
</html>
