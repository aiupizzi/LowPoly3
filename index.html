<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Three.js + Cannon-es Demo</title>
    <style>
      html,
      body {
        margin: 0;
        height: 100%;
        overflow: hidden;
      }

      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <script type="module">
      import * as THREE from 'https://unpkg.com/three@0.165.0/build/three.module.js';
      import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

      // Scene setup
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb);

      const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        100
      );
      camera.position.set(0, 5, 10);
      camera.lookAt(0, 0, 0);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      document.body.appendChild(renderer.domElement);

      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
      directionalLight.position.set(5, 10, 5);
      scene.add(directionalLight);

      // Physics world setup
      const world = new CANNON.World({
        gravity: new CANNON.Vec3(0, -9.82, 0),
      });

      // Mesh/body pairs to sync every frame
      const pairs = [];

      const groundBody = new CANNON.Body({ mass: 0 });
      const groundShape = new CANNON.Plane();
      groundBody.addShape(groundShape);
      groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
      world.addBody(groundBody);

      const groundMesh = new THREE.Mesh(
        new THREE.PlaneGeometry(50, 50),
        new THREE.MeshStandardMaterial({ color: 0x2e8b57 })
      );
      groundMesh.rotation.x = -Math.PI / 2;
      scene.add(groundMesh);
      pairs.push({ mesh: groundMesh, body: groundBody });

      const boxBody = new CANNON.Body({
        mass: 1,
        shape: new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5)),
        position: new CANNON.Vec3(0, 4, 0),
      });
      world.addBody(boxBody);

      const boxMesh = new THREE.Mesh(
        new THREE.BoxGeometry(1, 1, 1),
        new THREE.MeshStandardMaterial({ color: 0xff7f50 })
      );
      scene.add(boxMesh);
      pairs.push({ mesh: boxMesh, body: boxBody });

      // Basic keyboard state (WASD)
      const keys = {
        KeyW: false,
        KeyA: false,
        KeyS: false,
        KeyD: false,
      };

      window.addEventListener('keydown', (event) => {
        if (event.code in keys) {
          keys[event.code] = true;
        }
      });

      window.addEventListener('keyup', (event) => {
        if (event.code in keys) {
          keys[event.code] = false;
        }
      });

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      const clock = new THREE.Clock();
      const fixedTimeStep = 1 / 60;

      function animate() {
        const delta = Math.min(clock.getDelta(), 0.1);
        world.step(fixedTimeStep, delta, 3);

        // Example movement force from keyboard state
        const moveForce = 5;
        if (keys.KeyW) boxBody.applyForce(new CANNON.Vec3(0, 0, -moveForce), boxBody.position);
        if (keys.KeyS) boxBody.applyForce(new CANNON.Vec3(0, 0, moveForce), boxBody.position);
        if (keys.KeyA) boxBody.applyForce(new CANNON.Vec3(-moveForce, 0, 0), boxBody.position);
        if (keys.KeyD) boxBody.applyForce(new CANNON.Vec3(moveForce, 0, 0), boxBody.position);

        for (const { mesh, body } of pairs) {
          mesh.position.copy(body.position);
          mesh.quaternion.copy(body.quaternion);
        }

        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }

      requestAnimationFrame(animate);
    </script>
  </body>
</html>
