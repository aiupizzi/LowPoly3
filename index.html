<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Three.js + Cannon-es Demo</title>
    <style>
      html,
      body {
        margin: 0;
        height: 100%;
        overflow: hidden;
      }

      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <script type="module">
      import * as THREE from 'https://unpkg.com/three@0.165.0/build/three.module.js';
      import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

      // Scene setup
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb);

      const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        150
      );
      camera.position.set(0, 6, 12);
      camera.lookAt(0, 1, 0);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      document.body.appendChild(renderer.domElement);

      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
      directionalLight.position.set(5, 10, 5);
      scene.add(directionalLight);

      // Physics world setup
      const world = new CANNON.World({
        gravity: new CANNON.Vec3(0, -9.82, 0),
      });

      // Mesh/body pairs to sync every frame
      const pairs = [];

      const groundBody = new CANNON.Body({ mass: 0 });
      const groundShape = new CANNON.Plane();
      groundBody.addShape(groundShape);
      groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
      world.addBody(groundBody);

      const groundMesh = new THREE.Mesh(
        new THREE.PlaneGeometry(50, 50),
        new THREE.MeshStandardMaterial({ color: 0x2e8b57 })
      );
      groundMesh.rotation.x = -Math.PI / 2;
      scene.add(groundMesh);
      pairs.push({ mesh: groundMesh, body: groundBody });

      const carGroup = new THREE.Group();
      scene.add(carGroup);

      const bodySize = { x: 2.4, y: 0.7, z: 1.4 };
      const bodyMesh = new THREE.Mesh(
        new THREE.BoxGeometry(bodySize.x, bodySize.y, bodySize.z),
        new THREE.MeshStandardMaterial({ color: 0xff7f50, flatShading: true })
      );
      bodyMesh.position.y = 0.65;
      carGroup.add(bodyMesh);

      const wheelSize = { x: 0.45, y: 0.45, z: 0.3 };
      const wheelGeometry = new THREE.BoxGeometry(wheelSize.x, wheelSize.y, wheelSize.z);
      const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x1f1f1f, flatShading: true });
      const wheelOffsets = [
        new THREE.Vector3(0.75, 0.3, 0.65),
        new THREE.Vector3(-0.75, 0.3, 0.65),
        new THREE.Vector3(0.75, 0.3, -0.65),
        new THREE.Vector3(-0.75, 0.3, -0.65),
      ];

      for (const offset of wheelOffsets) {
        const wheelMesh = new THREE.Mesh(wheelGeometry, wheelMaterial);
        wheelMesh.position.copy(offset);
        carGroup.add(wheelMesh);
      }

      const carBody = new CANNON.Body({
        mass: 6,
        position: new CANNON.Vec3(0, 3, 0),
        linearDamping: 0.35,
        angularDamping: 0.45,
      });
      carBody.addShape(
        new CANNON.Box(new CANNON.Vec3(bodySize.x * 0.5, bodySize.y * 0.5, bodySize.z * 0.5)),
        new CANNON.Vec3(0, bodyMesh.position.y, 0)
      );

      for (const offset of wheelOffsets) {
        carBody.addShape(
          new CANNON.Box(new CANNON.Vec3(wheelSize.x * 0.5, wheelSize.y * 0.5, wheelSize.z * 0.5)),
          new CANNON.Vec3(offset.x, offset.y, offset.z)
        );
      }
      world.addBody(carBody);
      pairs.push({ mesh: carGroup, body: carBody });

      // Basic keyboard state (WASD)
      const keys = {
        KeyW: false,
        KeyA: false,
        KeyS: false,
        KeyD: false,
      };

      window.addEventListener('keydown', (event) => {
        if (event.code in keys) {
          keys[event.code] = true;
        }
      });

      window.addEventListener('keyup', (event) => {
        if (event.code in keys) {
          keys[event.code] = false;
        }
      });

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      const clock = new THREE.Clock();
      const fixedTimeStep = 1 / 60;
      const moveForce = 32;
      const steerTorque = 20;
      const forwardLocal = new CANNON.Vec3(0, 0, -1);
      const forwardWorld = new CANNON.Vec3();
      const forceVector = new CANNON.Vec3();
      const upAxis = new CANNON.Vec3(0, 1, 0);
      const currentVelocity = new CANNON.Vec3();
      const targetCameraPos = new THREE.Vector3();
      const carForward = new THREE.Vector3();
      const cameraUpOffset = new THREE.Vector3(0, 4, 0);

      function animate() {
        const delta = Math.min(clock.getDelta(), 0.1);
        world.step(fixedTimeStep, delta, 3);

        carBody.quaternion.vmult(forwardLocal, forwardWorld);

        if (keys.KeyW) {
          forwardWorld.scale(moveForce, forceVector);
          carBody.applyForce(forceVector, carBody.position);
        }
        if (keys.KeyS) {
          forwardWorld.scale(-moveForce, forceVector);
          carBody.applyForce(forceVector, carBody.position);
        }

        currentVelocity.copy(carBody.velocity);
        currentVelocity.y = 0;
        const speed = currentVelocity.length();
        if (speed > 0.2) {
          const steerInput = (keys.KeyA ? 1 : 0) - (keys.KeyD ? 1 : 0);
          if (steerInput !== 0) {
            const directionSign = Math.sign(currentVelocity.dot(forwardWorld)) || 1;
            upAxis.scale(steerInput * steerTorque * speed * 0.08 * directionSign, forceVector);
            carBody.torque.vadd(forceVector, carBody.torque);
          }
        }

        for (const { mesh, body } of pairs) {
          mesh.position.copy(body.position);
          mesh.quaternion.copy(body.quaternion);
        }

        carForward.set(0, 0, -1).applyQuaternion(carGroup.quaternion);
        targetCameraPos
          .copy(carGroup.position)
          .addScaledVector(carForward, -8)
          .add(cameraUpOffset);
        camera.position.lerp(targetCameraPos, 0.1);
        camera.lookAt(carGroup.position.x, carGroup.position.y + 1, carGroup.position.z);

        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }

      requestAnimationFrame(animate);
    </script>
  </body>
</html>
